\chapter{Primitives de mouvement}
\label{chap:primitive}

\epigraph{Text text text text text text text text text text text text
  text text text text text text text text text text text text text
  text text text text text text text text text text text text text
  text text text text text text text text text text text text text
  text text text text}{Some Author}
\clearpage

\section{Problématique}

Le chapitre précédent a introduit la possibilité d'asservir une
trajectoire de marche sur un robot humanoïde. Cependant, les tâches
accomplies par les robots humanoïdes ne se limitent pas à la
locomotion et il est intéressant de se demander s'il est possible de
combiner aux tâches de navigation d'autres tâches asservies par les
données capteurs afin de réaliser des comportements complexes. De
manière indirecte, la question qui se pose ici est celle de la limite
à placer entre d'une part raisonnement numérique et d'autre part
raisonnement logique. Ce problème récurrent de la robotique et pour
lequel il n'existe pas, de consensus au sein de la communauté trouve
ici une solution élégante. En effet, un contrôleur fondé sur le
paradigme de la pile de tâche ne se limite pas à une description
d'objectifs ou de contraintes robotiques dans des espaces plus
naturels que l'espace des configurations ou l'espace cartésien, il
ouvre surtout la voie à des méchanismes de supervision décidant à quel
moment insérer telle ou telle tâche à un niveau de priorité donné. La
pile de tâche réalise donc la jonction entre d'une part, le monde du
calcul numérique puisque la finalité du système est de calculer la
commande du système et d'autre part le monde de la logique dans lequel
les utilisateurs humains souhaitent exprimer leur \emph{desiderata} au
système robotique: va jusqu'à la cuisine, apportes moi la bouteille,
ouvres la porte, etc. Il est clair que ce type d'ordre nécessite la
résolution d'abstractions et que la logique mathématique semble être
un moyen particulièrement adapté pour y parvenir. Ces méchanismes de
décision de haut niveau sont appelés ``superviseurs'' et ont pour
objectif d'instantier et d'orchestrer tous les composants d'une
architecture robotique. Dans le cadre de notre architecture, il faut
donc pouvoir instantier des piles de tâches à partir d'une description
de haut niveau des ordres passés au robot. Ce chapitre propose un
langage de description des tâches permettant de faire le lien entre
représentation logique et représentation numérique.


Nous allons commencer par détailler l'état de l'Art et en particulier
les autres travaux aillant trait aux architectures robotiques haut
niveau et à l'ordonnancement de tâches ainsi que plus généralement aux
applications robotiques complexes. Dans un second temps, le langage de
description sera décrit et quelques scénarii types seront
démontrés. Enfin, nous nous concentrerons sur les problèmes
d'asservissement posés par les robots humanoïdes avant de conclure.


\section{\'Etat de l'Art}

FIXME

\section{Description d'un mouvement robotique complexe}


Décrire le comportement d'une pile de tâche revient à décrire deux
éléments primordiaux: d'une part les tâches exprimées dans le solveur
et de l'autre les différents changements d'état de la pile au cours du
mouvement. Concernant les tâches, il s'agit ici de représenter des
fonctions mathématiques génériques ne présentant pas de point commun
permettant une représentation générique de ces dernières. Par exemple
si l'on se limitait aux fonctions linéaires $\mathbf{A}(t) \mathbf{x}
+ \mathbf{b}(t)$, encoder la matrice $\mathbf{A}$ et le vecteur
$\mathbf{b}$ serait envisageable pour un ensemble discret de valeur
$t$ données. Le cas évoqué est trop contraint pour notre problème et
les modélisations informatiques développées dans le chapitre 1 n'aide
pas: elles ont pour but de venir fournir un modèle pour l'expression
d'une fonction mathématique sous la forme d'un algorithme et non pas
sous la forme d'une donnée structurée pouvant facilement être encodée.
Le choix a donc été fait de définir un ensemble de tâches permettant
de réaliser un certain nombre d'actions intéressantes. Rien n'empêche
alors cet ensemble de ``primitives'' d'être étendu au cours du temps
mais il nécessite l'extension du modèle de description défini ici.


La second partie est la représentation des changements d'état. Un
changement d'état du solveur survient quand une tâche est: ajoutée,
supprimée ou bien encore quand sa priorité est modifiée. De manière
générale les transitions peuvent être soit temporelles -- avance de 5
mètres puis saisit la poignée de la porte --, soit logique -- si tu es
à moins de 10 cm de la position finale, arrêtes-toi --. Pour
comprendre la stratégie choisit, il faut garder à l'esprit que pour
réaliser un scénario complexe certains comportements seront intégrés
dans la boucle de temps réel tandis que d'autres -- typiquement les
informations capteurs -- seront traitées à l'extérieur. Les deux
catégories d'événements, temporelles ou logiques, ne mettent pas en
jeu les mêmes méchanismes. Les événéments temporels sont décidés à
l'avance et doivent être exécutés avec une grande précision pour
assurer un comportement correct du système tandis que les événéments
logiques sont le résultat d'un méchanisme de décision externe.

De ce fait, la stratégie adoptée a été de permettre la représentation
de transitions temporelles dans le modèle de description uniquement
tandis que l'on considère que les transitions événémentielles, de fait
plus lentes et difficiles à encoder, sont gérées à l'extérieur du
contrôleur par un logiciel décisionnel aillant la possibilité de
regénérer le mouvement s'il devient invalide suite à la réception
d'une nouvelle donnée capteur. De nombreux logiciels adaptés à cette
tâche ont été développés tel que
SMACH\footnote{\url{http://www.ros.org/wiki/smach}}.


\subsection{Primitive de mouvement}

La première tâche a été de définir des primitives de mouvement de
haut-niveau. Les primitives proposées sont:
\begin{enumerate}
\item La locomotion: mouvement synchronisé des deux jambes et du
  centre de masse du robot pour réaliser un déplacement tout en
  assurant sa stabilité.
\item La manipulation et le contact: mouvement réalisant le placement
  d'une partie spécifiée du robot à un emplacement donné dans l'espace
  Euclidien. La tâche peut contraindre la position et/ou la rotation
  du corps à positionner.
\item Regard ou asservissement visuel: le robot doit maintenir un
  point dans son champ de vision.
\end{enumerate}


\subsection{Primitive de locomotion}

Une tâche de locomotion est définie intialement comme une série de
points de contact à réaliser pour atteindre une position
finale. Chacun des points de contact étant annoté par l'effecteur
devant réaliser le contact à cet endroit. À partir de ces
informations, une trajectoire des effecteurs réalisant les appui est
déduite ainsi que du centre de masse pour préserver l'équilibre
dynamique du système. Afin de pouvoir utiliser les techniques décrites
dans le chapitre FIXME, nous nous limiterons à la marche sur un sol
plat utilisant le pied gauche et le pied droit du robot. Le calcul de
la trajectoire des effecteurs et du centre de masse est encore un
problème ouvert à l'heure actuelle. Les modèles simples peuvent être
embarqués dans les contrôleurs au prix de nombreuses simplifications
détaillées dans le chapitre précédent tandis que les modèles les plus
compliqués nécessitent une résolution hors du contrôleurs rendant le
comportement du système non-réactif. Le chapitre précédent a proposé
une stratégie pour fusionner les avantages des deux approches. Nous
considérons ici la totalité de l'approche développée au cours du
chapitre précédent comme une implémentation d'une primitive de
locomotion. En particulier, l'erreur de positionnement du robot est
considérée comme une entrée de la primitive de mouvement.


\subsubsection{Tâche d'alignement de deux repères}

Cette primitive de mouvement repose principalement sur la définition
d'une tâche où le solveur doit positionner un corps du robot à un
endroit précis à la fois en rotation et en translation. C'est cette
tâche qui va permettre de faire suivre la trajectoire des pieds
notamment.


Soit $\mathbf{M}, \mathbf{M}^{*} \in \text{SE}(3)^2$
respectivement la position actuelle du corps du robot et la position
de référence à atteindre. On peut alors définir l'erreur de cette
tâche comme:

\begin{equation}
  \mathbf{e} = \mathbf{M} (\mathbf{M}^{*})^{-1}
\end{equation}

On remarquera que dans l'équation FIXME, $\mathbf{e}$ est un élément
de $\text{SE}(3)$. Les élements de $\text{SE}(3)$ peuvent s'exprimer
de nombreuses façons différentes: matrice homogène -- 16 paramètres
--, translation et quaternion -- 7 paramètres --, vecteur de rotation
-- 6 paramètres --, etc. Il faut garder à l'esprit qu'une
paramétrisation minimale de $\text{SE}(3)$ nécessite six
paramètres. De fait, tout représentation utilisant un espace de
dimension supérieure vient avec un ensemble de contraintes à respecter
car tous les éléments de cet espace de dimension supérieur ne peuvent
faire parti de $\text{SE}(3)$. Par exemple, une matrice homogène a une
structure bien particulière tel qu'illustré sur la figure FIXME. Quant
aux quaternions, seuls les quaternions unitaires définissent une
bijection avec $\text{SO}(3)$, l'espace des rotations dans l'espace
3d.

De fait, les représentations non minimales ne représentent pas une
solution acceptable pour représenter notre erreur car elles provoquent
l'insertion de contraintes supplémentaires inutiles dans le problème
d'optimisation. Il faut donc choisir pour représenter $\mathbf{e}$ une
représentation minimale, dans notre cas via une translation et une
rotation autour d'un axe.

En effet, toute rotation peut être représentée par trois paramètres
\mbox{$\mathbf{\theta} = (\alpha, \beta, \gamma) \in \mathrm{R}^3$}. Le
vecteur $(\alpha, \beta, \gamma)$ normalisé représentant l'axe autour
duquel la rotation s'effectue et la norme du vecteur
$|\mathbf{\theta}|$ la quantité de rotation réalisée autour de cet
axe, voir figure FIXME.

Cette représentation est minimale car la translation est représentée
par trois paramètres et la rotation par trois paramètres:

\begin{equation}
  \mathbf{e} = \left(
  \begin{array}{c}
    t_x\\
    t_y\\
    t_z\\
    \theta_x\\
    \theta_y\\
    \theta_z
  \end{array}
  \right)
\end{equation}

En considérant les trois premiers éléments du vecteur d'erreur ou bien
les trois derniers on peut restreindre la tâche à positioner le corps
respectivement en translation ou en rotation uniquement.


\subsubsection{Tâche de position du centre de masse}


Le second type de tâche nécessaire pour définir la primitive de
locomotion est la tâche de positionnement du centre de masse.

Cette tâche nécessite la connaissance du poids de tous les corps du
robot $m_i$ où $i \in \mathcal{B}$. $\mathcal{B}$ l'ensemble des corps
du robot. Le centre de masse du robot est alors défini comme le
barycentre des centres de masse de chaque corps:

\begin{equation}
  \mathbf{x} = \frac{1}{\sum_{i \in \mathcal{B}} m_i} \sum_{i \in \mathcal{B}} m_i \mathbf{x}_i
\end{equation}

$\mathbf{x}$ représentation la position du centre de masse du robot et
$\mathbf{x}_i$ la position du centre de masse du corps $i$.

L'erreur de positionnement du centre de masse est alors simplement:

\begin{equation}
  \mathbf{e} = \mathbf{x} - \mathbf{x}^{*}
\end{equation}

La définition de l'erreur ne posant pas de difficulté ici car
$\mathbf{x}$ est un élément de $\mathrm{R}^3$.


\subsubsection{Définition de la primitive de locomotion}

Une tâche de locomotion est par nature critique: un mauvais suivi de
la trajectoire de référence du centre de masse ou bien encore de la
trajectoire des pieds aboutit à une perte de l'équilibre du robot. De
ce fait, établir une priorité entre ces tâches n'a pas de sens. On
préférera donc exprimer ces trois tâches -- pied gauche, pied droit et
centre de masse -- de la façon suivante:

\begin{equation}
  \mathbf{e} = \mathbf{e}_{\text{pied gauche}} + \mathbf{e}_{\text{pied droit}} + \mathbf{e}_{\text{centre de masse}}
\end{equation}

Les équations formulées dans cette section peuvent enfin être
paramétrées par le temps courant $t$ afin de permettre une
modification de la valeur de référence notée $\mathbf{M}^*$ ou
$\mathbf{x}^*$ selon les cas et permettre le suivi d'une trajectoire
plutôt que l'atteinte d'une référence constante.


Comme décrit dans le chapitre précédent, l'erreur des tâche décroît
exponentiellement -- dans le cas où la référence reste constante
--. Un suivi suffisamment précis de la trajectoire est alors
réalisable en augmentant suffisamment $\lambda$ le gain associé à la
tâche. Dans la mesure où l'erreur initiale de cette tâche est nulle --
le mouvement commence à la position actuelle du robot -- et varie de
manière continue, la tâche ne génère pas de grandes vitesses
articulaires malgré le gain important.


\subsubsection{Primitive de manipulation}


La primitive de manipulation est une instance directe de la tâche
d'alignement de repères présentées dans la section précédente. Elle
est utilisée pour placer la main à un endroit donnée afin de saisir un
objet. Le déplacement d'un bras du robot ne mettant pas en jeu
l'équilibre du robot tant qu'elle se déplace peu rapidement et sans
perturber la tâche de suivi du centre de masse, on peut simplement
corriger l'erreur de positionnement de la main avec une interpolation
linéaire pour amener la main à la position désirée.


\subsubsection{Primitive de regard}


La dernière primitive introduite ici concerne l'asservissement de la
trajectoire du robot afin de préserver des amères dans une zones où
elles sont détectables par les capteurs du robot. Sur le robot HRP-2,
seul des caméras sont à la disposition des utilisateurs et leur
placement dans la tête permet naturellement de définir une tâche de
``regard'' où l'utilisateur souhaite garder un point au centre de
l'image captée par une caméra du robot.

Soit \mbox{$M = (X, Y, Z) \in \mathrm{R}^3$} un point 3d dont les
coordonnées sont définies par rapport à la position de la caméra du
robot et \mbox{$m = (x, y) \in \mathrm{R}^2$} sa projection sur le
plan image de la caméra. On a alors la relation suivante:

\begin{equation}
  \mathbf{m} = \left(
  \begin{array}{c}
    x\\
    y
  \end{array}
  \right) = \left(
  \begin{array}{c}
    X / Z\\
    Y / Z
  \end{array}
  \right)
\end{equation}


Une fois de plus l'erreur se définit par la soustraction usuelle:

\begin{equation}
  \mathbf{e} = \mathbf{m} - \mathbf{m}^*
\end{equation}


\subsection{Langage de description}

Le langage de description adopté est le YAML -- Yet Another Markup
Language --~\citep{yaml}. Le fichier est divisé en trois parties:
\begin{description}
\item[En-tête] fournissant les méta-informations sur le mouvement, notamment sa durée en secondes.
\item[Primitives de mouvement] définissant quelles primitives sont
  jouées et sur quel intervalle, ainsi que la configuration de chaque
  primitive.
\item[Primitives d'asservissement] définissant comment l'erreur de
  positionnement du robot est estimée au fil du temps.
\end{description}


\subsubsection{Primitive de locomotion}

Une primitive de locomotion est définie par un ensemble de points de
contacts définis sur la forme d'une pile de pas.

\begin{description}
\item[Intervalle] Date de début et de fin de la primitive de mouvement.
\item[Empreinte de pas] Liste des pas à effectuer. Les pas sont
  considérés comme des éléments de $\text{SE}(2)$ dans la mesure où
  l'algorithme de génération de pas fait l'hypothèse d'un sol
  planaire.
\end{description}

Lors du chargement du plan, la génération des trajectoires de pieds et
de centre de masse initial est réalisé hors-ligne de manière
asynchrone. Tant que le calcul n'est pas terminé, il n'est pas
possible de lancer le mouvement.


\subsubsection{Primitive de manipulation}

Une primitive de manipulation est définie par un corps et une position
6d de référence. L'objectif est de faire coïncider le corps avec la
position 6d de référence. Cette tâche peut ne considérer que la
rotation ou la translation.

\begin{description}
\item[Intervalle] Date de début et de fin de la primitive de manipulation.
\item[Corps à considérer] Nom du corps à considérer. Des noms
  génériques ont été définis tels que: cheville gauche, cheville
  droite, poignet gauche, poignet droit, tête, torse et bassin.
\item[Consigne] La position de référence vers lequel le corps doit
  être amené. Il peut être de trois types. Soit statique, le corps
  doit maintenir sa position initiale, soit fixe dans ce cas le corps
  doit atteindre un point prédéterminé de l'espace, soit dynamique
  dans ce cas le corps doit suivre un point mobile.
\end{description}


\subsubsection{Primitive de regard}

La primitive de regard définit comment le robot peut maintenir son
regard vers un point 3d, éventuellement mobile.

\begin{description}
\item[Intervalle] Date de début et de fin de la primitive de manipulation.
\item[Caméra à considérer] Nom de la caméra utilisée. En pratique, la
  caméra est définie comme un corps ``virtuel'' du robot et l'on peut
  donc potentiellement aligner n'importe quel partie du corps du robot
  vers un point donné.
\item[Consigne] La position de référence vers lequel le corps doit
  pointer. Il peut être de deux types. Soit fixe, dans ce cas le corps
  doit pointer vers un point prédéterminé de l'espace, soit dynamique
  et dans ce cas le corps doit pointer vers un point mobile.
\end{description}


\subsubsection{Asservissement des primitives sur les données capteur}


Une fois la séquence de mouvement définie, il faut encore pouvoir
fermer la boucle sur les données capteur. Dans le cadre d'un mouvement
complexe, une stratégie intéressante est de pouvoir s'asservir
successivement sur plusieurs amères afin de planifier \emph{a priori}
quelle est la ou les amères les plus pertinentes à différents instants.


Soit $\mathcal{L}$ un système de localisation. Un système de
localisation est défini comme une fonction qui à tout instant fournit
une pose estimée d'un corps de référence du robot, dans notre cas le
bassin. On a donc:

\begin{equation}
  \begin{array}{ccc}
    \mathcal{L} : & \mathrm{R} \rightarrow & \text{SE}(2)\\
    ~ & t \mapsto & \mathcal{L}(t)
  \end{array}
\end{equation}

Au cours du mouvement, $n$ systèmes de localisation fournissent une
estimation de la pose du robot. Une fois de plus, cette pose est
théoriquement dans l'espace 3d $\text{SE}(3)$ mais les contraintes
physiques font que seul trois degrés de liberté doivent être
réellement estimés: $(x, y, \theta) \in \text{SE}(2)$. Ces trois
degrés correspondent à la position 2d de la projection du bassin sur
le sol. De ce fait, l'interpolation de $n$ poses 2d et la moyenne des
poses à la normalisation de l'angle $\theta$ prêt.


On associe à chaque système de localisation une fonction de poids
déterminant l'influence relative des systèmes de localisation dans
l'estimation finale de la pose:

\begin{equation}
  \begin{array}{ccc}
    m_i : & \mathrm{R} \rightarrow & \mathrm{R}\\
    ~ & t \mapsto & m_i(t)
  \end{array}
\end{equation}

La fusion des données pour l'estimation de la pose est donc le
barycentre des poses 2d:

\begin{equation}
  \mathbf{\hat{x}}(t) = \frac{1}{\sum_{i \in n} m_i} \sum_{i \in n} m_i \mathcal{L}_i(t)
\end{equation}

En pratique, chaque système de localisation est représenté de la façon suivante:
\begin{description}
\item[Poids] en fonction du temps. Il peut soit être constant, soit
  varier dynamiquement.
\item[Erreur] de positionnement en fonction du temps. Elle est fournie
  par un système de localisation externe.
\end{description}



\section{Scénarii de mouvements}
\subsection{Locomotion simple}

\begin{figure}
  \begin{center}
\begin{verbatim}
duration: 200 # durée complète du mouvement (secondes)

# Éléments de mouvement
motion:
  # Primitive de locomotion
  - walk:
      interval: [0, 200] # Date de début et de fin de la primitive

      # Pile de pas
      footsteps:
      - {x: 0.15, y: -0.19, theta: 0., slide1: 0., slide2: -0.76}
      - {x: 0.15, y: +0.19, theta: 0.1, slide1: -1.00, slide2: -0.76}
      # etc.
\end{verbatim}
  \end{center}
  \caption{Plan de mouvement pour une séquence de marche non-asservie.}
\end{figure}

\subsection{Locomotion asservie}

\begin{figure}
  \begin{center}
\begin{verbatim}
duration: 200 # durée complète du mouvement (secondes)

# correction maximum autorisée sur un pas (x, y en mètre, theta en radians)
maximum-correction-per-step: {x: 0.02, y: 0.02, theta: 0.05}

# Éléments de mouvement
motion:
  # Primitive de locomotion
  - walk:
      interval: [0, 200] # Date de début et de fin de la primitive

      # Pile de pas
      footsteps:
      - {x: 0.15, y: -0.19, theta: 0., slide1: 0., slide2: -0.76}
      - {x: 0.15, y: +0.19, theta: 0.1, slide1: -1.00, slide2: -0.76}
      # etc.

# Asservissement des tâches
control:
  # Asservissement via le système de capture de mouvements.
  - mocap:
      weight: 1.
      tracked-body: left-ankle
      perceived-body: left-foot
\end{verbatim}
  \end{center}
  \caption{Plan de mouvement pour une séquence de marche asservie sur
    un système de localisation -- ici un système de capture de
    mouvement --.}
\end{figure}


\subsection{Scénario complexe avec tâche d'atteinte et asservissement corps complet}

\section{De la difficulté à localiser un robot humanoïde}
\subsection{Forces et limites du robot humanoïde HRP-2}
\subsection{Vision pour la robotique humanoïde}
\paragraph{Difficultés classiques de la vision}
\paragraph{Stabilisation de la tête}
\paragraph{Pourquoi un robot n'est pas une caméra volante}
\paragraph{Résultats de la localisation utilisant la vision sur le robot humanoïde HRP-2}

\section{Résultats}

\section{Conclusion}

\documentclass[14pt,utf8x,hyperref={pdfpagelabels=false}]{beamer}

\usepackage[utf8]{inputenc} % hyperref broken with utf8x
\usepackage[C40,T1]{fontenc}

\usepackage{graphicx}
\usepackage{array}
\usepackage{multirow}

\usepackage[francais]{babel}

\usepackage{algorithmic, algorithm}

\usepackage{tikz, pgfplots}
\usepackage{tikz-qtree}

\newcommand{\umltextcolor}{ThoughfulBrick}
\newcommand{\umldrawcolor}{Thoughtless}
\newcommand{\umlfillcolor}{ThoughtBySome}
\usepackage{pgf-umlcd}

\usetikzlibrary{shapes.arrows,chains,positioning,%
  matrix,patterns,shapes.multipart,positioning,arrows}

\tikzstyle{every picture}+=[remember picture]
\tikzstyle{na} = [baseline=-.5ex]

\tikzstyle{state}=[rectangle,
  color=structure.fg,
  fill=ThoughtBySome,
  inner sep=0.2cm,
  rounded corners=2mm]

\tikzset{
  template parameter/.style={
        append after command={
            node [draw, densely dashed, umlcolor, font=\ttfamily]
                at (\tikzlastnode.north east)
                {#1}
        }
    }
}

\newcommand{\tikzplaceholder}[1]{\begingroup\shorthandoff{;}\tikz[na] \node[coordinate] (#1) {};\endgroup}

\newcommand{\blueoverlay}[2]{\tikz[baseline]{ \node[fill=blue!20,anchor=base,rounded corners=2pt] (#1) {$#2$}; }}

\usetheme{moulardthesis}

\DeclareUnicodeCharacter{00A0}{~}

\title{Optimisation numérique\\
  Exécution~de~trajectoires référencées capteurs}
\author{Thomas Moulard}
\date{Lundi 17 septembre 2012}


% Setup pdf meta-data.
\hypersetup{
pdfauthor = {Thomas Moulard},
pdftitle = {Optimisation num\'erique pour la robotique%
 et ex\'ecution de trajectoires r\'ef\'erenc\'ees capteurs},
pdfsubject = {Optimisation num\'erique pour la robotique%
 et ex\'ecution de trajectoires r\'ef\'erenc\'ees capteurs},
pdfkeywords = {optimisation numérique, typage, type,%
robotique, humano\"ide},
pdfcreator = {Thomas Moulard},
pdfproducer = {Thomas Moulard}
}


\begin{document}

{
  \usebackgroundtemplate{%
    \includegraphics[width=\paperwidth,height=\paperheight]{%
      src/slides/demo1.jpg}}
  \begin{frame}[plain]
    \titlepage
  \end{frame}
}

%\maxFrameImage{src/slides/demo1.jpg}
%\maxFrameImage{src/slides/demo2.jpg}

% Introduction
% Animated scheme introducing contributions.
\begin{frame}
  \begin{changemargin}{-1cm}{-1cm}
    \begin{center}
      \tikzstyle{normalPath} = [line width=.7mm, color=black!50, -latex]

      \begin{tikzpicture}[
          auto,
          state/.style={
            rectangle,
            minimum size=6mm
          }]

        \uncover<1->{
          \node (perception) [state] {%
            \includegraphics[height=3cm]{%
              src/slides/perception.pdf}};
        }

        \uncover<1>{
          \node (perception-description)
                [state, right=of perception]
                {\textbf{Perception}};
        }


        \uncover<2->{
          \node (decision)
               [state,above right=of perception] {%
            \includegraphics[height=3cm]{%
              src/slides/decision.pdf}};
        }

        \uncover<2>{
          \node (decision-description)
                [state, right=of decision]
                {\textbf{Décision}};
        }

        \uncover<3->{
        \node (action) [state,below right=of decision]{%
          \includegraphics[height=3cm]{%
            src/slides/action.pdf}};
        }

        \uncover<3>{
          \node (action-description)
                [state, left=of action]
                {\textbf{Action}};
        }

        \uncover<4->{
          \path (perception) edge[->, normalPath] (decision);
        }

        \uncover<5-8>{
          \path (decision) edge[->, normalPath] (action);
        }

        \uncover<6->{
          \path (action.south)
          edge[->, normalPath, dashed, bend right, bend left]
          node[color=black!50,above=5pt] {Monde réel}
          (perception.south);
        }

        \uncover<7->{
          \node (contrib) [state,left=of decision]{%
            \usebeamerfont{section}\large\textbf{Contributions}};

          \node (contrib1b) [state,right=1pt of decision]{%
            (1) RobOptim};
        }
        \uncover<7>{
          \node[thick,draw=ThoughfulBrick] (contrib1)
               [state,above=-3.4cm of decision] {%
                 \phantom{\includegraphics[height=3.5cm]{%
                     src/slides/perception.pdf}}};
        }

        \uncover<8->{
          \path (perception.east)
          edge[->, normalPath,color=ThoughfulBrick]
          node[above=5pt] {(2) Correction}
          (action.west);
        }
        \uncover<8>{
          \node[thick,draw=ThoughfulBrick] (contrib2)
               [state,above=-3.4cm of action] {%
                 \phantom{\includegraphics[height=3.5cm]{%
                     src/slides/action.pdf}}};
        }


        \uncover<9->{
          \path (decision) edge[->, normalPath,color=ThoughfulBrick]
          node[color=ThoughfulBrick,text width=3.5cm]{%
            (3) Primitives de mouvement} (action);
        }

        \uncover<10->{
          \node (contrib4b) [state,above=10pt of perception]{%
            (4) Intégration};
        }
        \uncover<10>{
          \node[thick,draw=ThoughfulBrick] (contrib4)
               [state,above=-3.4cm of perception] {%
                 \phantom{\includegraphics[height=3.5cm]{%
                     src/slides/perception.jpg}}};
        }


      \end{tikzpicture}
    \end{center}
  \end{changemargin}
\end{frame}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Processus de décision}
    \begin{center}
      \includegraphics%
          [width=.75\linewidth]%
          {src/chap1-roboptim/hrp2-two-chairs.png}

          \begin{enumerate}
          \item Planification.
          \item Optimisation de la trajectoire trouvée.
          \end{enumerate}
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Optimisation}
    \begin{equation*}
      \min_{\mathbf{x} \in \mathbb{R}^n} f(\mathbf{x})%
      \text{ sous la contrainte } \mathbf{x} \in \mathbf{X}
    \end{equation*}

    \begin{equation*}
      \mathbf{X} \equiv \left\{
      \begin{array}{l l}
        c_i (x) = 0    & \quad i \in \xi \\
        c_j (x) \leq 0 & \quad j \in \nu \\
      \end{array} \right.
    \end{equation*}

  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Motivation}

    \begin{center}
      \begin{description}
        \item[Généricité] Un algorithme, un logiciel?
        \item[\ldots et efficacité] Meta-programmation.
      \end{description}
      \bigskip
      Quelle est la \alert{représentation informatique} d'un problème
      d'optimisation générique?
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}


\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Fonctions (1)}

    \begin{center}
      \footnotesize
    \begin{tikzpicture}[%
        y=.1\paperheight,
        auto]

      \begin{interface}[text width=7cm]{Fonction}{0,0}
        \attribute{+ taille de l'espace d'entrée: entier}
        \attribute{+ taille de l'espace de sortie: entier}
        \operation{+ calcul (vecteur): vecteur}
      \end{interface}

      \begin{interface}[text width=7cm]{Fonction dérivable}{0,-3}
        \inherit{Fonction}
        \operation{+ jacobien (vecteur): matrice}
      \end{interface}

      \begin{interface}[text width=7cm]{Fonction dérivable deux fois}{0,-6}
        \inherit{Fonction dérivable}
        \operation{+ hessien (vecteur, entier): vecteur}
      \end{interface}
    \end{tikzpicture}
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Fonctions (2)}

    \begin{center}
      \footnotesize
    \begin{tikzpicture}[%
        y=.1\paperheight,
        auto]

      \begin{interface}[text width=7cm]{Fonction dérivable deux fois}{0,0}
        \operation{+ hessien (vecteur, entier): vecteur}
      \end{interface}

      \begin{interface}[template parameter=n,text width=7cm]{%
          Fonction dérivable ``n'' fois}{0,-3}
        \inherit{Fonction dérivable deux fois}
        \operation{+ dérivée (vecteur, entier): vecteur}
      \end{interface}

%      \path[umlcd style inherit line, ultra thick]
%      (Fonction dérivable ``n'' fois.south) + (0,-0.1) --
%      (Fonction dérivable ``n'' fois.south) + (-0.1,0) --
%      (Fonction dérivable ``n'' fois.south) + (0,0.1);

    \end{tikzpicture}
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Problème}

    \begin{center}
      \footnotesize
    \begin{tikzpicture}[%
        y=.1\paperheight,
        auto]

      \begin{class}[template parameter={F,$C_1$,$\dotsc$,$C_n$},%
          text width=7cm]{Problème}{0,0}
        \attribute{+ estimation initiale: vecteur}
        \attribute{+ bornes: (double, double)[*]}
        \attribute{+ coût: \texttt{$F$}}
        \attribute{+ contraintes: (\texttt{$C_i$}, entier, entier)[*]}
      \end{class}
    \end{tikzpicture}

    \begin{equation*}
      \begin{split}
        F <: \text{Fonction}\\
        \forall i, C_i <: \text{Fonction}
      \end{split}
    \end{equation*}
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Solveur}

    \begin{center}
      \footnotesize
    \begin{tikzpicture}[%
        y=.1\paperheight,
        auto]

      \node[na] at (5,-1) (P) {P};

      \begin{class}[%
          template parameter={Problème<$F$,$C_1$,$\dotsc$,$C_n$>},
          text width=7cm]{Solveur}{0,0}
        \inherit{P}
        \attribute{+ problème: $\text{Problème}<F, C_1, \dotsc, C_n>$}
        \operation{+ résous (): vecteur}
      \end{class}

      \composition{Solveur}{}{1}{P}
    \end{tikzpicture}

    \begin{equation*}
      (F, C_1, \dotsc, C_n) <: Fonction^{n+1}
    \end{equation*}

    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Dérivation par différences finies}

    \begin{center}
      \footnotesize
      \begin{tikzpicture}[%
          y=.1\paperheight,
          auto]

      \node[na] at (0,0) (F) {F};

        \begin{class}[template parameter=F,%
            text width=7cm]{DifférencesFinies}{0,-2}
          \inherit{F}
          \attribute{- fonction: F}
          \operation{+ jacobien (vecteur): vecteur}
        \end{class}
      \end{tikzpicture}
    \end{center}
    \bigskip
    Design Pattern \alert{décorateur}.
  \end{changeleftmargin}
\end{slideDecision}


\begin{slideDecision}
  \begin{changeleftmargin}{1.1cm}
    \frametitle{Propriétés assurées par typage}

    \begin{center}
      \begin{description}
        \item[Correction]~\\
          Tout problème exprimable est bien formé.

        \item[Généricité]~\\
          Un solveur peut résoudre tous les problèmes de complexité
          ``égale'' ou ``inférieure'' à ses capacités.

        \item[Efficacité]~\\
          Un solveur peut résoudre un problème de complexité
          ``supérieure'' à condition de construire explicitement ce
          problème.
      \end{description}
    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{RobOptim}
  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    \tikzstyle{roboptim} = [align=center,
      rectangle,
      minimum size=6mm,
      minimum height=15mm,
      color=Thoughtless,
      fill=ThoughtBySome,
      line width=1pt,
      inner sep=0pt,
      outer sep=0pt,
      text width=70pt
    ]

    \begin{tabular}{cccl}
      \tikz \node[roboptim] (cfsqp) {CFSQP}; &
      \tikz \node[roboptim] (ipopt) {IPOPT}; &
      \tikz \node[roboptim] (cminpack) {CMinPack}; &
      \parbox[l][1.5cm][l]{2cm}{%
        \vspace{-.6cm}\rotatebox{-90}{\footnotesize \textbf{Solveur}}}\\
      \multicolumn{3}{c}{%
        \tikz \node[roboptim,
          text width=235pt] (core) {RobOptim Core};
      } &
      \parbox[l][1.5cm][l]{2cm}{%
        \vspace{-.6cm}\rotatebox{-90}{\footnotesize \textbf{Interface}}}\\
      \tikz \node[roboptim] (traj) {RobOptim Trajectory}; &
      \tikz \node[roboptim] (post) {RobOptim Posture}; &
      \tikz \node[roboptim] (others2) {\ldots}; &
      \parbox[l][1.5cm][l]{2cm}{%
        \vspace{-.6cm}\rotatebox{-90}{%
          \footnotesize \textbf{Application}}}\\
    \end{tabular}
  \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{Applications}

  \begin{center}
    \includegraphics[height=.33\paperheight]%
                    {src/chap1-roboptim/straight-line-obstacle.png}
  \includegraphics[height=.33\paperheight]%
                  {src/slides/agent-067.jpg}\par
  \includegraphics[height=.33\paperheight]%
                  {src/slides/multi-014.jpg}
  \includegraphics[height=.33\paperheight]%
                  {src/slides/multi-015.jpg}
%  \includegraphics[height=.33\paperheight]%
%                  {src/slides/deformable.jpg}

  Figures 2, 3, 4: K. Bouyarmane et collab.
  \end{center}
\end{slideDecision}


\begin{slideDecision}
  \frametitle{Génération de mouvements (1)}
  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    \includegraphics[width=.25\paperheight]{src/slides/falling.pdf}%
    \includegraphics[width=.25\paperheight]{src/slides/burning.pdf}\par
    \bigskip
    Quelles contraintes?\par
  \end{center}
  Limites en couple et vitesse,\\
  (auto-)collision et \alert{équilibre}.
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{Génération de mouvements (2)}
  \begin{changeleftmargin}{1.1cm}
    \begin{center}
      ZMP dans le polygone support $\Rightarrow$ mouvement
      dynamiquement stable.

      \bigskip

      \begin{tikzpicture}[%
          auto,
          footprint/.style={%
            rectangle,
            draw=black,
            ultra thick,
            minimum size=6mm,
            text width=8mm,
            decoration={brace},
        },
        fpLeft/.style={%
          footprint,
          decoration={brace, raise=-1.05cm},
        },
        fpRight/.style={%
          footprint,
          decoration={brace, raise=1.05cm},
        },
        supportPolygon/.style={%
          draw,
          ultra thick
        },
        zmpPoint/.style={%
          fill=ThoughfulBrick,
        }]

        \matrix[ampersand replacement=\&,
          row sep=1cm, column sep=.5cm]{%
            \uncover<1-3> {
              \node[fpLeft] (l0) {};
            } \&
            \&
            \uncover<5-> {
              \node[fpLeft] (l1) {};
            }\\
%
            \uncover<1> {
              \node[fpRight] (r0) {};
            }\&
            \uncover<3-5> {
              \node[fpRight] (r1) {};
            } \&
            \&
            \uncover<7-> {
              \node[fpRight] (r2) {};
            }\\
          };

        % 1/ double support.
        \uncover<1> {
          \path[supportPolygon]
          (l0.north west) -- (r0.south west)
          -- (r0.south east) -- (l0.north east) -- cycle;

          \draw[zmpPoint] (barycentric cs:l0=1/2,r0=1/2) circle (1mm);
        }

        % 2/ single support, left
        \uncover<2> {
          \path[supportPolygon]
          (l0.north west) -- (l0.south west)
          -- (l0.south east) -- (l0.north east) -- cycle;

          \draw[zmpPoint] (l0) circle (1mm);
        }

        % 3/ double support lr
        \uncover<3> {
          \path[supportPolygon]
          (l0.north west) -- (l0.north east)
          -- (r1.north east) -- (r1.south east) -- (r1.south west)
          -- (l0.south west) -- cycle;

          \draw[zmpPoint] (barycentric cs:l0=1/2,r1=1/2) circle (1mm);
        }

        % 4/ single support, right
        \uncover<4> {
          \path[supportPolygon]
          (r1.north west) -- (r1.south west)
          -- (r1.south east) -- (r1.north east) -- cycle;

          \draw[zmpPoint] (r1) circle (1mm);
        }

        % 5/ double support rl
        \uncover<5> {
          \path[supportPolygon]
          (l1.north west) -- (l1.north east)
          -- (l1.south east)
          -- (r1.south east) -- (r1.south west)
          -- (r1.north west) -- (l1.north west)
          -- cycle;

          \draw[zmpPoint] (barycentric cs:l1=1/2,r1=1/2) circle (1mm);
        }

        % 6/ single support, left
        \uncover<6> {
          \path[supportPolygon]
          (l1.north west) -- (l1.south west)
          -- (l1.south east) -- (l1.north east) -- cycle;

          \draw[zmpPoint] (l1) circle (1mm);
        }

        % 3/ double support lr
        \uncover<7> {
          \path[supportPolygon]
          (l1.north west) -- (l1.north east);
          \path[supportPolygon]
          (l1.north west) -- (l1.south west);


          \path[supportPolygon]
          (r2.south west) -- (r2.south east);
          \path[supportPolygon]
          (r2.south east) -- (r2.north east);

          \path[supportPolygon]
          (l1.south west) -- (r2.south west);
          \path[supportPolygon]
          (l1.north east) -- (r2.north east);

          \draw[zmpPoint] (barycentric cs:l1=1/2,r2=1/2) circle (1mm);
        }
      \end{tikzpicture}

    \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{Génération de mouvements (3)}
  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    \begin{equation*}
    \begin{array}{lll}
    x_{ZMP} &=& x_G -
    \frac{\dot{\sigma}_y\ +\ m\ z_G\ \ddot{x}_G}{m\ (\ddot{z}_G + g)}\\
    y_{ZMP} &=& y_G +
    \frac{\dot{\sigma}_x - m z_G \ddot{y}_G}{m (\ddot{z}_G + g)}
    \end{array}
  \end{equation*}

  \end{center}

  \begin{description}
    \item[$(x_G, y_G, z_G)$]~\\
      Position du centre de masse.
    \item[$(\sigma_x, \sigma_y)$]~\\
      Moment cinétique autour du centre de masse.
    \item[$m$] Masse du robot.
    \item[$g$] Constante de gravité.
  \end{description}

  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{Génération de mouvements (4)}
  \begin{changeleftmargin}{1.1cm}
  \begin{center}

    Modèle linéaire:

    \begin{equation*}
      z = x - \frac{z_G}{g} \ddot{x}_G
    \end{equation*}

    \begin{description}
    \item[$z$] Position du ZMP.
    \item[$x$] Position du centre de masse.
    \item[$z_G$] Hauteur du centre de masse.
    \item[$g$] Constante de gravité.
    \end{description}
  \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\begin{slideDecision}
  \frametitle{Génération de mouvements (5)}
  \begin{changeleftmargin}{1.5cm}
  \begin{center}
    \begin{enumerate}
      \item Génération d'une pile de pas.
      \item Génération d'une trajectoire de ZMP.
      \item Génération de la trajectoire de centre de masse
        correspondante.
      \item Génération des trajectoires de pieds.
    \end{enumerate}

    \bigskip

    \alert{Et la trajectoire corps complet?}
  \end{center}
  \end{changeleftmargin}
\end{slideDecision}

\maxFrameImageWidth{src/chap3-primitive-mouvement/footsteps1.jpg}

%\maxFrameImageWidth{src/slides/goal-generation.png}
\maxFrameImageWidth{src/slides/over.jpg}

\begin{slideAction}
  \frametitle{Contrôleur polyvalent (1)}

  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    Contrôleur: algorithme générant la commande envoyée aux moteurs à
    une fréquence fixe (200Hz pour HRP-2).

    \bigskip

    \begin{itemize}
    \item Exécute les tâches générées par la partie décisionelle.
    \item En charge de l'adaptation réactive du mouvement.
    \item Respecte le temps réel.
    \end{itemize}

    \bigskip

    Composant \alert{critique} de tout robot.
  \end{center}
  \end{changeleftmargin}
\end{slideAction}

\begin{slideAction}
  \frametitle{Contrôleur polyvalent (2)}

  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    Espace des tâches\\
    VS\\
    Espaces des configurations.

    \bigskip

    \begin{equation*}
      \mathbf{e} = \mathbf{s} - \mathbf{s}^{*}
    \end{equation*}

    \begin{description}
      \item[$\mathbf{e}$] erreur.
      \item[$\mathbf{s}$] valeur courante de la tâche.
      \item[$\mathbf{s}^{*}$] valeur de référence.
    \end{description}
  \end{center}
  \end{changeleftmargin}
\end{slideAction}

\begin{slideAction}
  \frametitle{Contrôleur polyvalent (2)}

  \begin{changeleftmargin}{1.1cm}
  \begin{center}

    \begin{tikzpicture}[%
        >=latex,
        node distance=1em,
        fixed/.style={
          text width=120pt}]
      \node [state,fixed] (com) {Centre de masse};
      \node [state,fixed, below=of com] (lf) {Pied gauche};
      \node [state,fixed, below=of lf] (rf) {Pied droit};
      \node [state,fixed, below=of rf] (posture) {Posture};

      \node [left=of com] (fort) {Priorité forte};
      \node [left=of posture] (faible) {Priorité faible};
      \draw[->, line width=1.05]
      (fort.south) -- (faible.north);
    \end{tikzpicture}
  \end{center}
  \end{changeleftmargin}
\end{slideAction}

\begin{slideAction}
  \frametitle{Schéma de contrôle boucle fermée}

  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    \begin{tikzpicture}[%
        >=latex]
      \node[state] (gen) {Génération};
      \node[state, below=of gen] (corr) {Correction};
      \node[state, below=of corr, align=left,inner sep=0.1ex,
        shape=rectangle split,
        rectangle split part align=left,
        rectangle split parts=5] (ctrl) {Contrôleur%
        \nodepart{two}\footnotesize{centre de masse}
        \nodepart{three}\footnotesize{pied gauche}
        \nodepart{four}\footnotesize{pied droit}
        \nodepart{five}\footnotesize{posture}};
      \node[state,right=2cm of corr] (loc) {Localisation};

      %\draw[-,style=dashed] (2,-3) -- (2,3);

      \uncover<3-> {
        \draw[->] (loc.west) -- (corr.east)
        node [at start,left,font=\tiny,yshift=0.2cm]
        {$\hat{\mathbf{x}}_t \in \text{SE}(2)$};
      }

      \uncover<2-> {
        \draw[->] (gen.south) -- (corr.north)
        node [at start,left,font=\tiny,yshift=-0.2cm]
        {$(\gamma_{\text{pieds}}(t), \gamma_{\text{com}}(t)) \in \text{SE}(3)^2 \times \mathbb{R}^3$};
      }

      \uncover<3-> {
        \draw[->] (corr.south) -- (ctrl.north)
        node [at start,left,font=\tiny,yshift=-0.25cm]
        {$(\gamma'_{\text{pieds}(t)}, \gamma'_{\text{com}}(t)) \in \text{SE}(3)^2 \times \mathbb{R}^3$};
      }

      \uncover<4-> {
        \draw[->] (ctrl.south) --++ (0,-1)
        node [at start,left,font=\tiny,yshift=-0.25cm]
        {$\dot{\mathbf{q}}_t \in \mathbb{R}^n$};
      }

      \draw[<-] (gen.north) --++ (0,1) node [left,font=\tiny,yshift=-0.25cm]
           {$\mathbf{S} \in \text{SE}(2)^{\text{nsteps}}$};
    \end{tikzpicture}
  \end{center}
  \end{changeleftmargin}
\end{slideAction}

\begin{slideAction}
  \frametitle{Synchronisation temporelle}


  \begin{center}
    \vspace{-1cm}
    \begin{tikzpicture}
      \begin{axis}[
          grid=major,
          legend style={
            at={(0.5,-0.2)},
            anchor=north,
            legend columns=3,
            cells={anchor=west},
            font=\footnotesize,
            rounded corners=2pt,
            draw=white
          },
          xlabel=time ($s$),
          ylabel=$x$ position ($m$),
          no markers
          ]

        \addplot[
          red,
          dashed,
        ] table {dat/feet_follower_feet-follower-com.dat};
        \addlegendentry{centre de masse}

        \addplot[
          blue,
          dashed,
        ] table[
          x index=0,
          y index=4
        ] {dat/feet_follower_feet-follower-left-ankle.dat};
        \addlegendentry{pied gauche}

        \addplot[
          green,
          dashed,
        ] table[
          x index=0,
          y index=4
        ] {dat/feet_follower_feet-follower-right-ankle.dat};
        \addlegendentry{pied droit}

        \uncover<7->{
        \addplot[
          red,
        ] table {dat/feet_follower_correction-com.dat};
        \addlegendentry{centre de masse (corr.)}
        }

        \uncover<6->{
        \addplot[
          blue,
        ] table[
          x index=0,
          y index=4
        ] {dat/feet_follower_correction-left-ankle.dat};
        \addlegendentry{pied gauche (corr.)}
        }

        \uncover<5->{
        \addplot[
          green,
        ] table[
          x index=0,
          y index=4
        ] {dat/feet_follower_correction-right-ankle.dat};
        \addlegendentry{pied droit (corr.)}
        }
      \end{axis}

      \uncover<2-> {
        \draw [
        thick,
        decoration={
          brace,
          raise=-1.05cm
        },
        font=\tiny,
        decorate
      ] (axis cs:2.1,6.35) -- (axis cs:4.1,6.35)
      node [pos=0.5,anchor=north,yshift=-0.55cm] {pas 1};
      }

      \uncover<3-> {
      \draw [
        thick,
        decoration={
          brace,
          raise=-1.05cm
        },
        font=\tiny,
        decorate
      ] (axis cs:5.1,6.35) -- (axis cs:7.1,6.35)
      node [pos=0.5,anchor=north,yshift=-0.55cm] {pas 2};
      }

      % error measure
      \uncover<4-> {
      \draw[<-]
      (1.3, 0.5) -- (1.3, 1.5)
      node [font=\tiny,anchor=north,yshift=0.3cm, line width=1.3]
      {mesure};
      }

      \def\w{0.5}
      \def\h{0.75}
      \def\dx{8.}

      \def\dy{.5}
      % left step planned 1
      \filldraw[pattern=north east lines] (\dx + 0., \dy + 0.5)
      rectangle (\dx + 0. + \w, \dy + \h + 0.5);

      % left step planned 1 - drift
      \uncover<4-> {
        \draw[style=solid,color=red,line width=1.25] (\dx, \dy - 0.3 + 0.5)
        rectangle (\dx + \w, \dy + \h - 0.3 + 0.5);
      }

      \filldraw[pattern=north east lines] (\dx + 1., \dy + 0.5)
      rectangle (\dx + 1. + \w, \dy + \h + 0.5);
      \draw<4->[style=solid,color=red,line width=1.25] (\dx + 1., \dy - 0.3 + 0.5)
      rectangle (\dx + \w + 1., \dy + \h - 0.3 + 0.5);


      % right step planned 1
      \filldraw[pattern=north east lines] (\dx + 1., \dy + 3.)
      rectangle (\dx + 1. + \w, \dy + \h + 3.)
      node [pos=0.5,anchor=north,font=\tiny,yshift=0.75cm] {pas 1};

      % right step planned 1 - corrected
      \uncover<4-> {
        \draw[style=solid,color=red,line width=1.25]
        (\dx + 1., \dy + 3.-0.3)
        rectangle (\dx + 1. + \w, \dy + \h + 3. -0.3);
      }


      \uncover<5-> {
        \draw[style=solid,color=green,line width=1.25] (\dx + 1., \dy + 3.)
        rectangle (\dx + 1. + \w, \dy + \h + 3.);
      }

      \def\dy{3.}
      % left step planned 2
      \filldraw[pattern=north east lines] (\dx + 0., \dy + 0.5)
      rectangle (\dx + 0. + \w, \dy + \h + 0.5)
      node [pos=0.5,anchor=north,font=\tiny,yshift=0.75cm] {pas 2};

      \uncover<4-> {
        \draw[style=solid,color=red,line width=1.25] (\dx, \dy + 0.5 -0.3)
        rectangle (\dx + \w, \dy + \h + 0.5 -0.3);
      }

      % left step planned 2 - corrected
      \uncover<6-> {
        \draw[style=solid,color=green,line width=1.25] (\dx + 0., \dy + 0.5)
      rectangle (\dx + 0. + \w, \dy + \h + 0.5);
      }

    \end{tikzpicture}
  \end{center}
\end{slideAction}

\begin{slideAction}
  \frametitle{Trajectoire des pieds (1)}

  \begin{center}
    \begin{tikzpicture}[>=latex]
        \def\w{0.5}
        \def\h{0.75}

        \foreach \dy in {0., 1., 2., 3.}
                 {
                   % left step planned
                   \filldraw[pattern=north east lines] (0., \dy)
                   rectangle (0. + \w, \dy + \h);

                   % right step planned
                   \filldraw[pattern=north west lines] (1., \dy + 0.5)
                   rectangle (1. + \w, \dy + \h + 0.5);
                 }

        % before correction
        \def\driftx{0.1}
        \def\drifty{0.05}
        \def\drifttheta{5.}

        \def\dy{0}
        % left step planned
        \draw<2->[style=solid, color=red, rotate=\drifttheta * \dy,line width=1.25]
        (0. + \driftx * \dy, \drifty * \dy + \dy)
        rectangle (0. + \driftx * \dy + \w, \drifty * \dy + \dy + \h);

        % right step planned
        \draw<3->[style=solid, color=red, rotate=\drifttheta * \dy + \drifttheta / 2.,line width=1.25]
        (1. + \driftx * \dy + \drifty / 2., \drifty * \dy + \drifty / 2. + \dy + 0.5)
        rectangle (1. + \driftx * \dy + \drifty / 2. + \w, \drifty * \dy + \drifty / 2. + \dy + \h + 0.5);

        \def\dy{1}
        % left step planned
        \draw<4->[style=solid, color=red, rotate=\drifttheta * \dy,line width=1.25]
        (0. + \driftx * \dy, \drifty * \dy + \dy)
        rectangle (0. + \driftx * \dy + \w, \drifty * \dy + \dy + \h);

        % right step planned
        \draw<5->[style=solid, color=red, rotate=\drifttheta * \dy + \drifttheta / 2.,line width=1.25]
        (1. + \driftx * \dy + \drifty / 2., \drifty * \dy + \drifty / 2. + \dy + 0.5)
        rectangle (1. + \driftx * \dy + \drifty / 2. + \w, \drifty * \dy + \drifty / 2. + \dy + \h + 0.5);


        \def\dy{2}
        \draw<6->[style=solid, color=red,line width=1.25, rotate=\drifttheta] (0. + \driftx, \dy + \drifty)
        rectangle (0. + \w + \driftx, \dy + \h + \drifty);

        % --- after correction ---

        % left step planned
        \draw<7->[style=solid, color=green,line width=1.25] (0., \dy)
        rectangle (0. + \w, \dy + \h);

        \uncover<7->{
        \draw[smooth,rounded corners=1ex,<-,thick]
        (-0.3, \dy) -- (-0.3 - 0.05, \dy + 0.2) -- (-0.3 - 0.2, \dy + 0.4)
        node[midway,left]
        {
          $\delta \mathbf{x}$
        };
        }


        \draw<7->[style=solid, color=green,line width=1.25] (0., \dy)
        rectangle (0. + \w, \dy + \h);
        \draw<7->[style=solid, color=green,line width=1.25] (1., \dy + 0.5)
        rectangle (1. + \w, \dy + \h + 0.5);
        \def\dy{3}
        \draw<7->[style=solid, color=green,line width=1.25] (0., \dy)
        rectangle (0. + \w, \dy + \h);
        \draw<7->[style=solid, color=green,line width=1.25] (1., \dy + 0.5)
        rectangle (1. + \w, \dy + \h + 0.5);

        % right step planned
        \def\dy{2}
        \draw<8->[style=solid, color=orange,line width=1.25, rotate=\drifttheta * 0.5] (1. + \driftx * .5, \dy + 0.5 + \drifty * 0.5)
        rectangle (1. + \driftx * 0.5 + \w, \dy + \drifty * 0.5 + \h + 0.5);

        \def\dy{3}
        % left step planned
        \draw<9->[style=solid, color=orange,line width=1.25, rotate=\drifttheta * 1.] (0. + \driftx * 1., \dy + \drifty * 1.)
        rectangle (0. + \w + \driftx * 1., \dy + \h + \drifty * 1.);

        % right step planned
        \uncover<10-> {
          \draw[style=solid, color=orange,line width=1.25, rotate=\drifttheta * 1.5] (1. + \driftx * 1.5, \dy + 0.5 + \drifty * 1.5)
        rectangle (1. + \w + \driftx * 1.5, \dy + \h + 0.5 + \drifty * 1.5);
        }

      \end{tikzpicture}
      \end{center}
\end{slideAction}

\begin{slideAction}
  \frametitle{Trajectoire des pieds (2)}

  \begin{equation*}
    \gamma_{\text{pied}}^{(1)}(t) = \Delta^t(t) . \gamma_{\text{pied}}(t)
  \end{equation*}

  \begin{equation*}
    \gamma_{\text{foot}}^{(n)}(t) =
    ( \prod_{i=0}^{n-1}\Delta^{t_{n-i}}(t) ) . \gamma_{\text{pied}}(t)
  \end{equation*}

\end{slideAction}

\begin{slideAction}
  \frametitle{Trajectoire du centre de masse}

  \begin{equation*}
    \mathbf{z} = \mathbf{c} - \frac{z_c}{g} \ddot{\mathbf{c}}
  \end{equation*}

  \begin{equation*}
    \mathbf{c}^{(n)}(t) =
    \underbrace{\scriptstyle \cosh(\sqrt{\frac{g}{z_c}}.t) . \mathbf{V} +
      \sinh(\sqrt{\frac{g}{z_c}}.t) . \mathbf{W} +
      \mathbf{r}(t)}_{\mathbf{c}(t) \in \mathbb{R}^2} + \sum_{i=1}^n \Delta^{t_i}(t)
  \end{equation*}

  \begin{center}
    $\mathbf{V}$, $\mathbf{W}$ déterminent la position et vitesse
    initiale.
  \end{center}

  \begin{equation*}
    \forall t \in \mathbb{R}, \Delta^t(0) = \dot{\Delta}^t(0) = 0
  \end{equation*}
\end{slideAction}

\maxFrameImageHeight{src/chap2-suivi-trajectoire/demo.jpg}

\maxFrameImageHeight{src/slides/door.jpg}

\begin{slideAction}
  \frametitle{Primitives de mouvement}

  \begin{changeleftmargin}{1.1cm}
  \begin{center}
    \begin{tikzpicture}[%
        node distance=1em,
        inner sep=0.1ex,
        outer sep=0.1ex,
        fixed/.style={
          text width=40pt}]

      \matrix[ampersand replacement=\&,
        row sep=.5cm, column sep=.5cm]{%
        \node {%
          \includegraphics[height=1.5cm]{src/slides/doorstate1.jpg}};\&
        \node {%
          \includegraphics[height=1.5cm]{src/slides/doorstate2.jpg}};\&
        \node {%
          \includegraphics[height=1.5cm]{src/slides/doorstate3.jpg}};\&
        \node {%
          \includegraphics[height=1.5cm]{src/slides/doorstate4.jpg}};\\
        \node[state,fixed] {\tiny{Équilibre}};\&
        \node[state,fixed] {\tiny{Équilibre}};\&
        \node[state,fixed] {\tiny{Équilibre}};\&
        \node[state,fixed] {\tiny{Équilibre}};\\
%
        \node [state,fixed] {\tiny{Bras gauche}};\&
        \node [state,fixed] {\tiny{Bras gauche}};\&
        \node [state,fixed] {\tiny{Bras droit}};\&
        \node [state,fixed] {\tiny{Posture}};\\
%
        \node [state,fixed] {\tiny{Posture}};\&
        \node [state,fixed] {\tiny{Bras droit}};\&
        \node [state,fixed] {\tiny{Posture}};\&
        \\
%
        \&
        \node [state,fixed] {\tiny{Posture}};\&
        \&
        \\

        \node[state,fixed,color=ThoughtBySome,fill=Thoughtless2]
             {\tiny{Porte}};\&
        \node[state,fixed,color=ThoughtBySome,fill=Thoughtless2]
             {\tiny{Poignée}};\&
        \node[state,fixed,color=ThoughtBySome,fill=Thoughtless2]
             {\tiny{Poignée}};\&
        \node[state,fixed,color=ThoughtBySome,fill=Thoughtless2]
             {\tiny{Poignée}};\\
      };
    \end{tikzpicture}
  \end{center}
  \end{changeleftmargin}
  \vbox{%
    \tikz \node[state,
      color=ThoughtBySome,fill=Thoughtless2] {\tiny{Asservissement}};
    \tikz \node[state] {\tiny{Tâche}};
  }
\end{slideAction}



%\maxFrameImageHeight{src/chap3-primitive-mouvement/calibextrinsic.jpg}

\begin{slidePerception}
  \frametitle{Systèmes de localisation}

  \begin{changeleftmargin}{1.1cm}
  \begin{description}
  \item[Capture de mouvement] Précision $\pm 1$ cm. Environnement
    instrumenté.
  \item[Tracker] Algorithme de vision. Précision à quelques
    centimètres près. Méthode locale.
  \item[Odométrie visuelle] Précision trop faible.
  \end{description}
  \end{changeleftmargin}
\end{slidePerception}

\maxFrameImageHeight{src/chap4-integration/shelf.png}

\begin{frame}
  \frametitle{Conclusion}

  \begin{itemize}
  \item Architecture complète: perception, décision, action.
  \item Correction des pas pour les mouvements de précision.
  \end{itemize}

  \bigskip

  \begin{itemize}
  \item Valider l'approche pour les bras.
  \item Valider les pas corrigés en-ligne.
  \item Améliorer la localisation du robot. Utilisation conjointe de
    plusieurs systèmes de localisation.
  \end{itemize}
\end{frame}

\maxFrameImageHeight{src/slides/hrp2-thx.jpg}


%
%\begin{slidePerception}
%  \frametitle{De la bibliothèque au composant}
%
%  FIXME
%\end{slidePerception}

%\maxFrameImageHeight{src/slides/demo2.jpg}

%\maxFrameImageHeight{src/chap4-integration/footsteps2.jpg}
%\maxFrameImageHeight{src/chap4-integration/disparity-1.jpg}
%\maxFrameImageHeight{src/chap4-integration/disparity-2.jpg}
%\maxFrameImageHeight{src/chap4-integration/hrp2_urdf.jpg}
%\maxFrameImageHeight{src/chap4-integration/rviz-full.jpg}



\end{document}
